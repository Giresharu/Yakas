# Yet Another KBL Auto Switch

<a href="https://github.com/Giresharu/YetAnotherKBLAutoSwitch/releases/latest">
<img src="https://img.shields.io/github/v/release/Giresharu/YetAnotherKBLAutoSwitch?logo=github" />
</a>
<a href="./LICENSE.md">
<img src="https://custom-icon-badges.demolab.com/github/license/Giresharu/YetAnotherKBLAutoSwitch?logo=law" />
</a>


另一款自动切换键盘布局工具，使用 AHK v2 编写，简称 YAKAS 。

## 特征
- 支持自定义按键，包括单个`修饰键`、单个`主键`，以及`组合键`。可以自由决定触发的按键。
- 支持多种按键触发方式：按下、按住一定时间、释放、限时内释放、按住一定时间后释放。限制触发的方式，能够大幅减少误触的情况。
- 支持多个热键，分别对应不同的切换方案（如 `Shift` 专用于切换英文与中文，`Ctrl` + `Shift` 专用于切换日文与英文）。
- 可以在任务栏图标显示当前语言与状态。这样一来可以隐藏傻逼 Windows 原生语言栏，防止点击任务栏时突然切换语言导致语言栏收缩从而不小心拖动图标的情况。
- 与 CapsLock+ 兼容。
- 智能管理进程的独立输入法，不仅可以设置进程开启时的默认键盘，还可以设置每次返回进程时恢复默认键盘，对某些只有短时间需要切换键盘的软件非常有价值。可以实现强制每次返回 QQ 进程时都恢复到中文输入法。
- 大写锁定同样可以跟随进程的独立输入法进行管理。
- 可以针对进程的某个特殊窗口进行独立的输入法管理，使其在本工具中单独作为一个『进程』来看待。靠指定窗口标题的正则表达式来进行区分。

## 关于管理员权限
本工具需要管理员权限才能正常工作，因为对于其他以管理员权限打开的进程，我们要修改它的键盘布局也同样需要管理员权限。首次打开时，请允许以管理员权限运行。
另外本工具也使用了键盘 Hook 功能，有顾虑可以阅读源码并自行编译，或者不使用本工具。

## 功能与配置

### 切换方案
切换方案指的是：可以被自定义热键触发，使当前进程在指定的键盘布局中循环切换的工具。可以有多个切换方案，以满足不同的需求。
要新建一个切换方案，只需要在 `setting.ini` 文件的 `KBLSwitch` 节中添加字段，并创建一个名为 `KBLSwitch.切换方案名称` 的节：
```ini
[KBLSwitch] ; 管理切换方案列表
0 = Switch_0

[KBLSwitch.Switch_0] ; 切换方案
key = LShift
condition = short_release(250)
layouts = en-US: 0, zh-CN: 1025
```
#### key
表示触发该切换方案的热键。
按照 AHK 的热键语法编写，可以是组合键、单个主键，或是单个修饰键。
##### 组合键
组合键分为一至多个修饰键，以及一个主键。例如 `Ctrl` + `Shift` + `A` ，其中 `A` 就是主键。
按照 AHK 的语法，应该写为：
```ini
key = ^+A ; ^ 表示 Ctrl 键，+ 表示 Shift 键
```
修饰键的对应符合见下表格：

| 修饰键 | 符号 |
| --- | --- |
| Ctrl  | ^  |
| Alt   | !  |
| Shift | +  |
| Win   | #  |

如要限定左右修饰键，可以在需要的修饰键符号前加上对应的 `<` `>` 符号：
```ini
key = <^<+A ; 左 Ctrl + 左 Shift + A
```

##### 单个主键
输入法也可以由单个主键触发，一般情况下非常不推荐。
但如果你是客制化键盘爱好者，可以使用专用的按键来触发切换方案，这样既不用组合键，也不用担心修饰键带来的误触问题。
```ini
key = Vn22 ; 使用虚拟键 22 
```

##### 单个修饰键
也可以使用单个修饰键来触发切换方案。实际上，这就是一种『单个主键』。
我们应该把修饰键写为原本的名称，而非组合键中提到的符号，这样写出来的修饰键就会作为主键被使用：
```ini
key = Shift ; Shift 键
```
如要限定左右修饰键，可以在需要的修饰键符号前加上对应的 `L` `R` ：
```ini
key = LShift ; 左 Shift 键
```
顺便一说，这种写法下， AHK 本身不支持不带左右的 `Win` 键，也就是只支持 `LWin` `RWin` 两个键。但是我在程序里特地做了一些处理，所以现在可以用 `Win` 了。

##### 补充说明
聪明的你也许想到了，既然单个修饰键本质上就是单个主键，那么组合键中，是否可以使用这个办法，来让其中一个修饰键当作主键呢？
答案是可以：
```ini
key = ^Shift ; Ctrl + Shift 键
```
也就是说：纯符号不行，多个主键也不行，符号 + 单键，行！

但是这样会有一个小问题：组合键中，主键一定要最后按下才会触发。也就是说，上面的写法必须先按下 `Ctrl` 键，然后按下 `Shift` 键，最后才会触发切换方案。这对于喜欢同时按下的朋友来说可能会产生失灵的问题。
有一个比较笨的解决办法，就是再新建一个其他字段都一模一样的切换方案，唯独把 `key` 字段改成 `+Ctrl` 即可。相当于有两套方案防止按键顺序问题。
```ini
[KBLSwitch] 
0 = Switch_0 
1 = Switch_1 ; 记得要将新切换方案添加进 KBLSwitch 的字段

[KBLSwitch.Switch_0]
key = ^Shift

[KBLSwitch.Switch_1] ; 新建一个切换方案，把 key 字段改成 +Ctrl
key = +Ctrl

```

为什么不修复呢？因为我认为这并不能算是一个 BUG ，在大部分软件的设计中，一定是修饰键先按下，最后按下主键才会触发的，这个设计语言不应该随意更改，否则会造成更多违背习惯的问题。

当然，多个修饰键之间的顺序是无所谓的，唯一要确保的只有主键要最后按下。

#### condition
表示触发切换方案的条件。
支持的写法分别有：
- `press`：表示按下后就立刻触发，长按的话会重复触发。
- `long_press(时间)`：表示按住一定时间后触发，单位为毫秒。
- `release`: 表示释放后触发。
- `short_release(时间)`：表示释放时如果没有超时则触发。
- `long_release(时间)`：表示按住一定时间后再释放才触发。

使用时间限制可以大幅降低在一些经常使用修饰键的软件中误触的概率。比如在 Photoshop 中常常使用 Shift 作为等比例操作的热键，如果使用 `press` 或者 `release` 则每次使用 Shift 时都会触发切换方案，非常的烦人。这时候就可以使用限制时长 `short_release` 来减少这种情况：
```ini
condition = short_release(250) ; 按下热键后，在 250 毫秒内释放才触发
```

#### layouts
表示切换方案可以切换的键盘布局顺序。
用逗号 `,` 分割多个键盘布局，每个键盘布局用冒号 `:` 分割，前面填写 `语言代码` ，后面填写输入法 `状态值`：
```ini
layouts = en-US: 0, zh-CN: 1025
```
##### 状态值
其中输入法状态是输入法的状态，大部分输入法中，`0` 表示英文状态。
在大部分中文输入法中 `1025` 表示中文状态。
大部分日文输入法中 `9` 表示平假名状态， `11` 表示片假名状态。

但这并不是绝对的，部分输入法并没有按照设计规范来编写代码，状态值可能不同，需要查阅资料或亲自尝试才能获得具体的值。
后续我可能会添加获取输入法当前状态的功能，以方便用户获取状态值。但是如同上面所说，部分输入法没有按照设计规范来编写，甚至有些输入法根本就不是为了 Windows 编写，从而使用自己的服务的（比如小狼毫输入法）。所以本工具无法修改这些输入法的状态。

##### 切换逻辑
在使用切换方案时，会将将输入法切换到下一个，首尾循环。
但是如果有多个切换方案，且他们的 layouts 列表不同，这时候触发其中一个切换方案，会发生什么呢？

该工具是这样做切换逻辑的：
1. 首先检查该进程最后使用的切换方案，以及最后切换到的 layouts 的索引；
2. 如果最后使用的切换方案与当前触发的切换方案相同，则索引 +1 ，切换到下一个键盘布局；
3. 如果之前从未使用过切换方案，或者最后使用的切换方案与当前触发的切换方案不同，则从当前触发的切换方案的 layouts 列表中，从前往后找最『相似』的布局，当作当前的布局。『相似』的定义是：如果有语言与状态值都相等的，则认为是相似的；否则退而求次，寻找语言相等的布局。
4. 如果找到相似的布局，则以该布局的索引 +1 来切换到下一个键盘布局；
5. 如果找不到相似的布局，则触发索引 0 的布局。

### 自动上屏
如果使用中文入法自带的中英文状态切换键的话，可以将在中文状态输入的拼音，在切换到英文状态时自动打上屏幕。这个功能就叫做自动上屏。

本工具支持你在不同语言切换时也能够达成自动上屏的效果，但是必须将需要自动上屏的输入框窗口的 class 名称填入 `setting.ini` 文件的 `AutoSendString` 节中：

```ini
[AutoSendString]
0 = PalmInputUICand 	; 手心输入法
1 = QQPinyinCompWndTSF  ; QQ 拼音输入法
2 = QQWubiCompWndII	    ; QQ 五笔输入法
3 = SoPY_Comp			; 搜狗拼音输入法
4 = SoWB_Comp	    	; 搜狗五笔输入法
```

若你使用的输入法不在以上列表中，请根据以下方法获取并添加：
1. 右键 YetAnotherKBLAutoSwitch 的状态栏图标，选择打开 Windows Spy；
2. 在任意地方使用你想添加的输入法，随意输入文字，使得输入窗口出现；
3. 将鼠标移到输入窗口上，观察 Windows Spy 窗口，找到最上方的框中的第二行 ahk_class ，把后面的文字添加进 `AutoSendString`；
4. 要注意的是 Windows Spy 的内容会随着鼠标的位置变换，如果你要复制的话，请在获取到输入窗口后，按住 Shift 来阻止它刷新。

自动上屏的方式实际是自动按下 `Enter` ，如果你发现有的输入法不是用这个按键来把拼音上屏的，可以提 Issue 告诉我。

### 全局设置
全局设置在 `setting.ini` 文件的 `GlobalSetting` 节中：
```ini
[GlobalSetting]
StandAlong = true 
CleanOnProcessExit = false
DefualtKBL = en-US: 0
Lag = 10 
RemenberCaps = true 
CleanCapsOnSwitched = true 
CleanCapsOnRecovered = false
```
#### StandAlong
指的是各个进程之间独立管理键盘布局的模式，以下称为 `独立模式` 。
开启独立模式后，每个进程都会独自记录自己当前所使用的键盘。从其他进程切换回来时，会恢复之前记录的键盘。
如关闭则为 `全局模式` ，会对所有进程的键盘进行统一管理，视作一个『进程』。修改一个进程的键盘，会影响到其他进程。

其实本工具概念中的『进程』并不是真正意义上的进程。不是通过 pid 而是通过名称或路径来进行区分的，也就是说同一个软件打开多个的话，会被当作同一个进程来管理。而包含多个进程的软件，也只针对窗口所属的进程进行管理。

#### CleanOnProcessExit
退出进程时是否清除该进程的键盘布局。如果清理，下次启动时：
- 独立模式：恢复到默认键盘布局。
- 全局模式：如果该进程有单独的配置，将所有进程的键盘都切换到该进程的默认键盘布局。否则，使用全局当前的键盘布局。

如关闭则会保留进程退出时的键盘布局，下次启动时：
- 独立模式：恢复到该进程的上次退出时的键盘布局。
- 全局模式：使用全局当前的键盘布局，不做修改。


#### DefualtKBL
全局的默认键盘布局，用冒号分割 `:` ，前面填写 `语言代码` ，后面填写输入法 `状态值`。

#### Lag
切换键盘到设置输入法的状态值的间隔时间，单位为毫秒。
某些输入法的加载速度比较慢，如果设置的太短，可能会导致状态值设置的失败。
请根据自己的实际情况设置。

#### RemenberCaps
进程是否记住 CapsLock 状态，在切换回进程时，会将 CapsLock 的状态恢复。
在全局模式下，这个配置没有意义。

#### CleanCapsOnSwitched
手动触发切换方案，改变输入法时，是否清除 CapsLock 状态。

#### CleanCapsOnRecovered
恢复到默认键盘布局时，是否清除 CapsLock 状态。

### 进程配置
进程配置在 `setting.ini` 文件的 `ProcessSetting` 节中。
用于对特定进程设置不同于全局的默认键盘布局，以及是开启每次回到进程都强制恢复默认键盘布局的功能。
也可以在此设置窗口规则，使窗口脱离进程的管理。
```ini
0 = Code.exe, en-US: 0, true ; VSCode 打开时默认使用英文，并且每次回到该进程都会恢复英文，方便写代码。
1 = Code.exe, .*\.md, en-US: 0, false ; VSCode 打开 Markdown 文件时默认使用英文，但不会因为每次回到该进程都会恢复到英文，可以方便一边查资料一边写博客。
```
参数用逗号 `,` 分割，按照顺序依次为： `进程`, `窗口标题`, `默认键盘布局`, `是否总是恢复`。其中 `窗口` 是可选的。

#### 进程
可以是进程名，也可以是进程路径。
大部分情况下使用进程即可，但如果好巧不巧，有人做的软件撞车了，进程名一样，那么可以使用路径来区分。
路径应该使用反斜杠 `\` 作为路径分隔符。
```ini
0 = editors.exe, zh-CN: 1025, false ; 像 ONLYOFFICE 这样的软件，进程名是 editors.exe，就很容易被其他软件撞车，所以推荐写成路径。
0 = D:\Program Files\ONLYOFFICE\DesktopEditors\editors.exe, zh-CN: 1025, false 
```

#### 窗口标题
用正则表达式来匹配窗口。
除了前面提到的给打开 Markdown 的 VSCode 提供单独配置以外，还有更重要的用途：
有些软件在打开时，实际上所属的进程是 Python 或者 Java 。这样就没有办法对具体的软件进行区分，此时我们可以通过窗口标题来区分他们。
```ini
0 = javaw.exe, Minecraft.*, en-US: 0, false ; 对 Minecraft 进行单独配置，而不影响其他 Java 软件
```
 
#### 默认键盘布局
属于该进程/窗口的默认键盘布局，
用冒号分割 `:` ，前面填写 `语言代码` ，后面填写输入法 `状态值`。
在启动进程时会切换到这个键盘布局。

#### 是否总是恢复
是否总是恢复到默认键盘布局，不仅是启动进程时会切换到默认键盘布局，回到该进程时也会。

### 切换提示
在切换语言时，会弹出提示框，提醒切换的语言。

#### 全局配置
全局配置于 `setting.ini` 文件的 `GlobalToolTip` 节中：
```ini
[GlobalToolTip]
text_color = 0x5090FF ; 文字颜色
bg_color = 0x252525 ; 背景颜色
alpha = 233 ; 不透明度
font_size = 14 ; 字体大小
font_style = bold  ; 字体风格
font_family = 思源黑体  ; 字体
duration = 750  ; 持续显示时间
fadeTime = 750  ; 淡出时间，单位毫秒
offset = 0.1  ; 偏移量
```

##### text_color
提示框的文字颜色，用十六进制表示，不包括 Aplha 通道。

##### bg_color
提示框的背景颜色，用十六进制表示，不包括 Alpha 通道。

##### alpha
提示框的不透明度，取值范围 0~255。

##### font_size
提示框的字体大小，会影响提示框的大小。

##### font_style
提示框的字体风格，可以是 `bold` 、 `italic` 、 `underline` 等，用空格分隔。
（我也不知道具体还有哪些，感兴趣可以自己试试，或者去 AHK V2 的文档看看 GUI 中的 Font 部分）

##### font_family
提示框的字体。

##### duration
提示框的持续显示时间，单位毫秒。

##### fadeTime
提示框的淡出时间，单位毫秒。

##### offset
文字的偏移量，表示偏移的比例。正直为向上偏移，负值表示向下偏移。
字体之间的基线位置不同，AHK 的 GUI 没有考虑到非西文的对齐问题，强迫症可以通过这个参数自行调整。

#### 语言独立配置

要创建语言的独立配置，需要在 `setting.ini` 文件的 `ToolTip` 节中添加字段，并创建一个名为 `ToolTip.语言` 的节：

```ini
[ToolTip]
en-US = US
zh-CN = CN

[ToolTip.US]
text_color = 0x5090FF 
text = En
captical_text = A

[ToolTip.CN]
text_color = 0xCC5050
text = 中
captical_text = ZH
```
`ToolTip` 节中添加的字段名必须与语言代码匹配。
独立配置中，可以填写所有 GlobalToolTip 的参数，对齐进行覆盖。此外，还有一些参数：

##### text
提示框要显示的文字，可以用逗号 `,` 分割多个文字，以及用 `状态值:` 来区分不同状态值所显示的文字：

```ini
text = あ, 11: カ  ; 片假名状态（11）下显示「カ」
```
如果前面没有任何状态值，则表示默认显示的文字，只要没有匹配的状态值，都将显示这个文字。

##### captical_text
大写状态时，提示框要显示的文字。写法与 `text` 相同。


### 状态栏图标
如切换提示一样，可以为不同语言以及不同的状态值设置不同的图标。
在 icons 文件夹已经内置了一些图标。如果你不满意或者想要更多语言或状态值的图标，可以直接制作，并添加进去。

添加图标的路径分别为：
```
指定状态值下的图标： 软件根目录\icons\语言代码\状态值.png
默认图标：软件根目录\icons\语言代码\icon.png
指定状态值下的大写图标： 软件根目录\icons\语言代码\Caps状态值.png
默认大写图标：软件根目录\icons\语言代码\Caps.png
```

图标的大小推荐为 16x16 像素。

### 感谢
- 本工具的诞生灵感来自 [KBLAutoSwitch](https://github.com/flyinclouds/KBLAutoSwitch) ，感谢 flyinclouds 的开源代码，即使是 v1 版本的代码，也给了我很多启发。本工具做出的一些特色，也只是站在巨人的肩膀上。

- 感谢 SKAN 提供的使用任务计划避免每次都出弹 UAC 的功能 [RunAsTask](https://www.autohotkey.com/boards/viewtopic.php?f=83&t=119710) 。

- 感谢 Descolada 提供的 [AHK-v2-libraries](https://github.com/Descolada/AHK-v2-libraries) 中的 WinEvent 相关函数，让本工具能够监听到窗口的创建、切换等事件，避免了循环检测。

- 感谢 plankoe 提供的 [GetCaretPos](https://www.reddit.com/r/AutoHotkey/comments/ysuawq/get_the_caret_location_in_any_program/) 函数，让本工具可以检测到 ACC 和 UIA 程序的输入框光标位置。

- 感谢 [AHK 官方论坛](https://www.autohotkey.com/boards/) 的各位高手，不厌其烦地为我解答 AHK 的各种问题。没有他们的解惑，我也无法在短时间内使用 AHK 这个语言开发出这款工具。

- 感谢 AHK 项目的维护者们，这款软件让对 Windows API 一窍不通的我也能做出一些简单的 hook 键盘操作。

### 吐槽
虽然很感谢 AHK ，但是我还是忍不住要吐槽一些东西：
- AHK 的索引是从 1 开始的，这让我很不习惯，对于一些在其他语言中已经很习惯的与索引有关的算法（比如求余限制数据范围），我搞了半天才发现索引不对。最高效的是，正则匹配出来的对象，索引又是从 0 开始的，可给我干懵逼了。
- AHK 的定时器可是个大坑，我在调试的时候经常发现手头上的函数还没执行完，就突然跳转到定时器去了。
- AHK 的类写起来太乱了，所有静态的成员，即使在类的内部，都必须用 类名.成员名 访问，类名稍微长一点，就能看到整个文件里一堆类名，简直就是精神污染。而 类名.方法名 的方法，还不能直接给 SetTimer 等的回调参数用，我只能用 Lambda 表达式套一层 () => 类名.方法名() 。
- 说到 Lambda 表达式，天呐，竟然不支持多行。加上 {} 也不行。
- 大小写不区分，我的妈呀，你知道这让我这个起名困难在给实例起名的时候有多痛苦吗？
- 别问我为什么这个代码写得这么混沌，就是上面的这些原因，使我已经燃尽，没有心情去重构了。